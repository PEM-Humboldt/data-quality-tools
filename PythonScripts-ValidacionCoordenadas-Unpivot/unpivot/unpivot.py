# -*- coding: utf-8 -*-
"""Reorganizar_Extensiones.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qlYsU5PDCLoMwlkympScTGURDPbWr03e

---
**SCRIPT REORGANIZAR EXTENSIONES**

---
"""

import pandas as pd
import numpy as np

# ============================================================================
# PARTE 1: CARGAR Y VERIFICAR DATASET
# ============================================================================

# Cargar el dataset
df = pd.read_csv('I2D-BIO_2015_IN050.csv')

# Verificación inicial
print("=== VERIFICACIÓN INICIAL ===")
print(f"Shape del dataset: {df.shape}")
print(f"Total de filas: {df.shape[0]}")
print(f"Total de columnas: {df.shape[1]}")
print(f"\nColumnas encontradas:")
for i, col in enumerate(df.columns, 1):
    print(f"  {i}. {col}")

# Hacer copia de seguridad
df_backup = df.copy()
print("\n✓ Copia de seguridad creada")

# ============================================================================
# PARTE 2: VERIFICAR NULOS E INCONGRUENCIAS.
# ============================================================================


print("\n=== REPORTE DE NULOS ===")

# Identificar columnas de extensiones
extensiones = {}
for col in df.columns:
    # Buscar measurementType1, measurementType2, etc.
    if 'measurementtype' in col.lower():
        num = col.lower().replace('measurementtype', '')
        if num not in extensiones:
            extensiones[num] = {}
        extensiones[num]['type'] = col

    # Buscar measurementUnit1, measurementUnit2, etc.
    if 'measurementunit' in col.lower():
        num = col.lower().replace('measurementunit', '')
        if num not in extensiones:
            extensiones[num] = {}
        extensiones[num]['unit'] = col

    # Buscar measurementValue1, measurementValue2, etc.
    if 'measurementvalue' in col.lower():
        num = col.lower().replace('measurementvalue', '')
        if num not in extensiones:
            extensiones[num] = {}
        extensiones[num]['value'] = col

print(f"Extensiones encontradas: {len(extensiones)}")

# Calcular total de nulos en todas las columnas de extensiones
total_nulos = 0
for num in extensiones.keys():
    ext = extensiones[num]
    if 'type' in ext:
        total_nulos += df[ext['type']].isnull().sum()
    if 'unit' in ext:
        total_nulos += df[ext['unit']].isnull().sum()
    if 'value' in ext:
        total_nulos += df[ext['value']].isnull().sum()

print(f"Total de nulos en todas las extensiones: {total_nulos}")
print()

# Analizar nulos en cada extensión (ordenar numéricamente)
# Separar las que tienen número de las que no
nums_con_numero = [n for n in extensiones.keys() if n.isdigit()]
nums_sin_numero = [n for n in extensiones.keys() if not n.isdigit()]

# Ordenar: primero las que no tienen número, luego las numeradas
nums_ordenados = sorted(nums_sin_numero) + sorted(nums_con_numero, key=int)

for num in nums_ordenados:
    ext = extensiones[num]
    print(f"Extensión #{num}:")

    if 'type' in ext:
        nulos = df[ext['type']].isnull().sum()
        print(f"  {ext['type']:30} → Nulos: {nulos}")

    if 'unit' in ext:
        nulos = df[ext['unit']].isnull().sum()
        print(f"  {ext['unit']:30} → Nulos: {nulos}")

    if 'value' in ext:
        nulos = df[ext['value']].isnull().sum()
        print(f"  {ext['value']:30} → Nulos: {nulos}")
    print()

# ============================================================================
# DEBUG: VALORES DENTRO DE LAS COLUMNAS
# SI LOS VALORES UNICOS > 1 NO CONTINUAR.
# SI LOS VALORES UNICOS SE REPITEN EN NOMBRE EN DIFERENTES EXTENSIONES NO CONTINUAR
# ---- RENOMBRAR ------
# EJ: "INTEPRETACION" presente en Extensión #13; Extensión #12 ; Extensión #16
# RENOMBRAR EN OPENREFINE PARA CADA EXT --> "INTERPRETACION13" "INTERPRETACION12"...
# O REALIZAR PROCESO MANUAL EN EXCEL.
# ============================================================================

print("\n=== DEBUG: VALORES ÚNICOS DENTRO DE CADA COLUMNA ===")

for num in nums_ordenados:
    ext = extensiones[num]
    print(f"\nExtensión #{num}:")

    if 'type' in ext:
        valores = df[ext['type']].dropna().unique()
        print(f"  Columna: {ext['type']}")
        print(f"  Valores únicos dentro: {len(valores)}")
        for v in valores[:5]:  # Mostrar máximo 5
            print(f"    - '{v}'")

# ============================================================================
# PARTE 3: UNPIVOT - REORGANIZAR LAS EXTENSIONES
# ============================================================================

print("=== REALIZANDO UNPIVOT ===")

# Lista para almacenar cada extensión transformada
dfs_list = []

# Procesar cada extensión (usar el mismo orden que antes)
for num in nums_ordenados:
    ext = extensiones[num]

    # Crear dataframe temporal con esta extensión
    df_temp = pd.DataFrame()
    df_temp['occurrenceID'] = df['occurrenceID']
    #df_temp['eventID'] = df['eventID'] #llave eventos, descomentar cuando sea asi.

    # Copiar las columnas renombradas
    if 'type' in ext:
        df_temp['measurementType'] = df[ext['type']]
    else:
        df_temp['measurementType'] = np.nan

    if 'unit' in ext:
        df_temp['measurementUnit'] = df[ext['unit']]
    else:
        df_temp['measurementUnit'] = np.nan

    if 'value' in ext:
        df_temp['measurementValue'] = df[ext['value']]
    else:
        df_temp['measurementValue'] = np.nan

    dfs_list.append(df_temp)
    print(f"✓ Extensión #{num} procesada")

# Concatenar todas las extensiones
df_final = pd.concat(dfs_list, ignore_index=True)

print(f"\n✓ Unpivot completado")
print(f"  Filas originales: {df.shape[0]}")
print(f"  Filas finales: {df_final.shape[0]}")
print(f"  Columnas finales: {df_final.shape[1]}")

# ============================================================================
# DEBUG: VERIFICAR QUÉ SE CONCATENÓ
# NO CONTINUAR SI LOS TYPES DEL DF FINAL NO COINCIDEN CON LOS CONCATENADOS
# ============================================================================

print("\n=== DEBUG: VERIFICACIÓN DE CONCATENACIÓN ===")
print(f"Número de dataframes concatenados: {len(dfs_list)}")
print(f"Extensiones en el diccionario: {len(extensiones)}")

# Ver qué measurementTypes únicos quedaron en el resultado
tipos_unicos = df_final['measurementType'].dropna().unique()
print(f"\nmeasurementTypes únicos en df_final: {len(tipos_unicos)}")
for tipo in sorted(tipos_unicos):
    count = (df_final['measurementType'] == tipo).sum()
    print(f"  '{tipo}' → {count} registros")

# ============================================================================
# PARTE 4: REPORTE POST-UNPIVOT
# ============================================================================

print("\n=== REPORTE POST-UNPIVOT ===")

# Contar nulos en cada columna
print("Nulos por columna:")
for col in df_final.columns:
    nulos = df_final[col].isnull().sum()
    porcentaje = (nulos / len(df_final)) * 100
    print(f"  {col:20} → {nulos:6} ({porcentaje:.1f}%)")

# Identificar filas donde las 3 columnas están vacías
filas_vacias = df_final[
    df_final['measurementType'].isnull() &
    df_final['measurementUnit'].isnull() &
    df_final['measurementValue'].isnull()
]

print(f"\n Filas con las 3 columnas vacías: {len(filas_vacias)}")

# ============================================================================
# PARTE 4.5: ELIMINAR FILAS VACÍAS
# ============================================================================

print("\n=== ELIMINANDO FILAS VACÍAS ===")

# Guardar el tamaño antes de limpiar
filas_antes = len(df_final)

# Eliminar filas donde las 3 columnas están vacías
df_final = df_final[~(
    df_final['measurementType'].isnull() &
    df_final['measurementUnit'].isnull() &
    df_final['measurementValue'].isnull()
)]

# Resetear el índice
df_final = df_final.reset_index(drop=True)

filas_despues = len(df_final)
filas_eliminadas = filas_antes - filas_despues

print(f" Filas antes de limpiar: {filas_antes}")
print(f" Filas eliminadas: {filas_eliminadas}")
print(f" Filas después de limpiar: {filas_despues}")
print(f" Porcentaje de datos conservados: {(filas_despues/filas_antes)*100:.1f}%")

# ============================================================================
# PARTE 4.7: ELIMINAR FILAS CON SOLO UNA COLUMNA LLENA (OPCIONAL / PASO SKIPEABLE EN OpenRefine)
#            !NO CORRER SI NO SE DESEA ELIMINAR UNA SOLA COLUMNA!
#            -------> PASAR A PARTE 5 ########
# ============================================================================
# Usar estas opciones si quieres ser más estricto con la limpieza
# Descomenta la línea que necesite según tu criterio

print("\n=== LIMPIEZA ADICIONAL (OPCIONAL) ===")

# Opción 1: Eliminar filas donde SOLO measurementType tiene valor
# (Unit y Value están vacíos)
print("\nOpción 1: Filas con solo Type lleno")
solo_type = df_final[
    df_final['measurementType'].notnull() &
    df_final['measurementUnit'].isnull() &
    df_final['measurementValue'].isnull()
]
print(f"  Filas encontradas: {len(solo_type)}")
# Descomenta la siguiente línea para eliminar:
# df_final = df_final[~((df_final['measurementType'].notnull()) & (df_final['measurementUnit'].isnull()) & (df_final['measurementValue'].isnull()))]

# Opción 2: Eliminar filas donde SOLO measurementUnit tiene valor
# (Type y Value están vacíos)
print("\nOpción 2: Filas con solo Unit lleno")
solo_unit = df_final[
    df_final['measurementType'].isnull() &
    df_final['measurementUnit'].notnull() &
    df_final['measurementValue'].isnull()
]
print(f"  Filas encontradas: {len(solo_unit)}")
# Descomenta la siguiente línea para eliminar:
df_final = df_final[~((df_final['measurementType'].isnull()) & (df_final['measurementUnit'].notnull()) & (df_final['measurementValue'].isnull()))]

# Opción 3: Eliminar filas donde SOLO measurementValue tiene valor
# (Type y Unit están vacíos)
print("\nOpción 3: Filas con solo Value lleno")
solo_value = df_final[
    df_final['measurementType'].isnull() &
    df_final['measurementUnit'].isnull() &
    df_final['measurementValue'].notnull()
]
print(f"  Filas encontradas: {len(solo_value)}")
# Descomenta la siguiente línea para eliminar:
df_final = df_final[~((df_final['measurementType'].isnull()) & (df_final['measurementUnit'].isnull()) & (df_final['measurementValue'].notnull()))]

## print("Para eliminar estas filas, descomenta la línea correspondiente")
## print("   Después ejecuta: df_final = df_final.reset_index(drop=True)")

# ============================================================================
# PARTE 5: EXPORTAR DF YA ORGANIZADO
# ============================================================================


print("\n=== EXPORTANDO RESULTADO ===")

# Guardar como CSV
df_final.to_csv('resultado_unpivot.csv', index=False)
print(" Archivo guardado: resultado_unpivot.csv")
print(f"  Total de filas exportadas: {len(df_final)}")

# Ver resultado final (Eliminar si no quiere los headers)
print("\nPrimeras 10 filas del resultado:")
print(df_final.head(10))

print("\n=== DEBUG: NOMBRES EXACTOS DE COLUMNAS ===")
measurement_cols = [col for col in df.columns if 'measurement' in col.lower()]
for col in sorted(measurement_cols):
    print(f"  {col}")